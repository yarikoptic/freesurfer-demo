/**
 * @file  mri_vol2vol.c
 * @brief converts values in one volume to another volume
 *
 * Resamples a volume into another field-of-view using various types of 
 * matrices (FreeSurfer, FSL, SPM, and MNI). This is meant to be used
 * in conjunction with tkregister2.
 *
 */
/*
 * Original Author: Doug Greve
 * CVS Revision Info:
 *    $Author: nicks $
 *    $Date: 2010/08/04 18:14:42 $
 *    $Revision: 1.63.2.1 $
 *
 * Copyright (C) 2002-2008,
 * The General Hospital Corporation (Boston, MA). 
 * All rights reserved.
 *
 * Distribution, usage and copying of this software is covered under the
 * terms found in the License Agreement file named 'COPYING' found in the
 * FreeSurfer source code root directory, and duplicated here:
 * https://surfer.nmr.mgh.harvard.edu/fswiki/FreeSurferOpenSourceLicense
 *
 * General inquiries: freesurfer@nmr.mgh.harvard.edu
 * Bug reports: analysis-bugs@nmr.mgh.harvard.edu
 *
 */

/*
BEGINUSAGE --------------------------------------------------------------

mri_vol2vol

  --mov  movvol       : input (or output template with --inv)
  --targ targvol      : output template (or input with --inv)
  --o    outvol       : output volume
  --disp dispvol      : displacement volume

  --reg  register.dat : tkRAS-to-tkRAS matrix   (tkregister2 format)
  --fsl  register.fsl : fslRAS-to-fslRAS matrix (FSL format)
  --xfm  register.xfm : ScannerRAS-to-ScannerRAS matrix (MNI format)
  --regheader         : ScannerRAS-to-ScannerRAS matrix = identity
  --mni152reg         : $FREESURFER_HOME/average/mni152.register.dat
  --s subject         : set matrix = identity and use subject for any templates

  --inv               : sample from targ to mov

  --tal               : map to a sub FOV of MNI305 (with --reg only)
  --talres resolution : set voxel size 1mm or 2mm (def is 1)
  --talxfm xfmfile    : default is talairach.xfm (looks in mri/transforms)

  --fstarg <vol>      : use vol <orig.mgz> from subject in --reg as target
  --crop scale        : crop and change voxel size
  --slice-crop sS sE  : crop output slices to be within sS and sE
  --slice-reverse     : reverse order of slices, update vox2ras
  --slice-bias alpha  : apply half-cosine bias field

  --trilin            : trilinear interpolation (default)
  --nearest           : nearest neighbor interpolation
  --interp interptype : interpolation trilin or nearest (def is trilin)

  --precision precisionid : output precision (def is float)
  --kernel            : save the trilinear interpolation kernel instead

  --no-resample : do not resample, just change vox2ras matrix

  --rot   Ax Ay Az : rotation angles (deg) to apply to reg matrix
  --trans Tx Ty Tz : translation (mm) to apply to reg matrix
  --shear Sxy Sxz Syz : xz is in-plane
  --reg-final regfinal.dat : final reg after rot and trans (but not inv)

  --synth : replace input with white gaussian noise
  --seed seed : seed for synth (def is to set from time of day)

  --no-save-reg : do not write out output volume registration matrix

  --help : go ahead, make my day
  --debug
  --version

ENDUSAGE ---------------------------------------------------------------
*/

/*
BEGINHELP --------------------------------------------------------------

Resamples a volume into another field-of-view using various types of
matrices (FreeSurfer, FSL, SPM, and MNI). This is meant to be used
in conjunction with tkregister2.

FLAGS AND ARGUMENTS

--mov movvol

This volume must have the same geometry as the --mov volume passed to
tkregister2 when creating/checking the registration file. By default,
this will be the input volume that will be resampled. If --inv is
specified, then this will become the geometry template for the output
instead.

--targ targvol

This volume must have the same geometry as the --targ volume passed to
tkregister2 when creating/checking the registration file. By default,
this will be the volume will be the geometry template for the output.
If --inv is specified, then this becomes the input volume that will be
resampled instead. The target volume can be implicitly specified with
--tal or --fstarg.

--reg register.dat

This simple text file contains the freesurfer registration matrix. It
is the same as the file passed to and generated by tkregister2 with
the --reg flag. If --tal or --fstarg is specified, then the subject
is obtained from the regfile.

--fsl register.fsl

Registration matrix created with the FSL flirt program using targ as
the reference and mov as input. Note: you cannot use any of the files
from $FSLDIR/etc/standard as mov or targ. These volumes do not have
geometry information in them, and FreeSurfer and FSL will default to
different things. Same as in tkregister2.

--xfm register.xfm

MNI-style registration matrix (eg, like one created with mritotal).
This matrix maps from mov Scanner-RAS to targ Scanner-RAS, where
'Scanner-RAS' is the vox2ras matrix as found in each file.
Same as in tkregister2.

--regheader

Create a registration matrix assuuming that the mov Scanner-RAS and
targ Scanner-RAS are the same. This is the same as using a register.xfm
with the identity matrix in it. This can be used with some SPM
registrations (which change only the matrix in the .mat file).
Same as in tkregister2.

--inv

Invert the transform. The movvol becomes the geometry template for the
output, and the targvol becomes the input that will be resampled.

--o outvol

Output volume.  By default, this will be the movvol resmapled into the
targvol space (and so will have the same geometry as the targvol). If
--inv is specified, then this will be the targvol resmapled into the
movvol space (and so will have the same geometry as the movvol). By
default, the output volume will be float, but this can be changed
with --precision. By default, the interpolation will be done with
trilinear, but this can be changed with --interp.

--tal

Resample the movvol to talairach (ie, MNI305) space. The talairach
matrix is obtained from talairach.xfm from
SUBJECTS_DIR/subjid/transforms. subjid is read from the register.dat
file. Requires --reg. Do not specify --targ as the target volume is
implicitly set to $FREESURFER_HOME/average/mni305.cor.subfovV.mgz,
where V is either 1 (for 1mm) or 2 (for 2mm). 2mm is used by default,
but this can be changed with --talres.  mni305.cor.subfovV.mgz the
MNI305 (1mm or 2mm isotropic) volume in a reduced FOV that covers only
the brain. Reducing the FOV saves space relative to the 256^3 COR FOV.
The transformation matrix is computed as R*inv(Xtal)*inv(Rtal), where
Xtal is talairach.xfm matrix, R is the matrix in the regfile, and Rtal
maps from the talairach COR FOV to the SubFOV (mni305.cor.subfovV.reg).
If you want to sample the targvol from talairach space into the movvol
space, then specify --inv. SUBJECTS_DIR is read from the environment
or can be specified with --sd.

--fstalres resmm

Set the resolution of the output when using --fstal. By default, it
is 2 mm, but can be changed to 1.0 mm with --fstalres 1

--fstarg <vol>

Set target to vol from the subject found in register.dat
file. If vol is not specified, uses orig.mgz. Requires --reg.  
Same as tkregister2.

--crop scale

Crop mov volume down to minimum size to fit non-zero voxels. The size of
the voxels is reduced by scale (ie, --crop 2 would crop and reduce the
voxel size by a factor of 2, eg 1.0 mm becomes 0.5 mm).

--slice-crop start end

Crop output volume to be within slices start and end. The geometry is 
updated to reflect the new limits.

--interp method

Interpolate the output based on the given method. Legal values are:
trilin and nearest. trilin is the default. Can also use --trilin
or --nearest.

--precision precisionid

Set output precision to precisionid. Legal values are uchar, short,
int, long, and float. Default is float.

--kernel

Save the trilinear interpolation kernel at each voxel instead of the
interpolated image.

--nomr

Don't copy the template MR parameters, but instead preserve the input volume 
ones

--help

Prints out all this information.

--gdiagno diagnostic level

Sets the diagnostic level (only good for debuggin').

--version

Print out version string and exit.


EXAMPLES:

Below are some exampls of how one might use mri_vol2vol. They are not
exhaustive of all the possible combinations of options. Typically, one
uses a template to establish the registration, then resamples data
that are in correspondence with the template.

1. If a functional volume is f.bhdr (or f.nii.gz, or f.mgh, etc), and the
subject is bert, and the registration file is register.dat, then
running the following command should show that they are in
registration:

tkregister2 --reg register.dat --mov f.nii.gz

If they are not, then fix it because nothing below is going to work. You
can also check the registration with:

tkmedit bert orig.mgz  -overlay f.nii.gz -overlay-reg register.dat

The register.dat will look something like this
----------------- register.dat --------------------------
bert
3.125
5.000
0.150000
1.000000e+00 0.000000e+00 0.000000e+00 -2.252487e+00
0.000000e+00 -8.902127e-01 4.555448e-01 2.342102e+00
0.000000e+00 4.555449e-01 8.902128e-01 -2.159538e-01
0.000000e+00 0.000000e+00 0.000000e+00 1.000000e+00
round
----------------- register.dat --------------------------

1.A. To resample the functional into anatomical space:

mri_vol2vol --reg register.dat --mov f.nii.gz --fstarg \\
   --o f-in-anat.mgh

f-in-anat.mgh will have the same size and geometry as
bert/mri/orig.mgz.  You can test the result in two ways:

  # This will show the low-res functional alighned with its resampled self
  tkregister2 --reg register.dat --mov f.nii.gz --targ f-in-anat.mgh

  # This will show the resampled functional aligned with the anatomical
  tkregister2 --mov f-in-anat.mgh --targ $SUBJECTS_DIR/bert/mri/orig.mgz \\
     --regheader --reg /tmp/reg

1.B. To resample the anatomical into the functional space. This is
basically the same command line as 1.A, but --inv has been included
and the name of the output is changed.

mri_vol2vol --reg register.dat --mov f.nii.gz --fstarg \\
  --o anat-in-func.mgh --inv

anat-in-func.mgh will be the same size and geometry as f.nii.gz.
You can test the result in two ways:

  # This will show the low-res anat aligned with its hires self
  tkregister2 --reg register.dat --mov anat-in-func.mgh

  # This will show the resampled anat aligned with the functional
  tkregister2 --mov anat-in-func.mgh --targ f.nii.gz \\
     --regheader --reg /tmp/reg

1.C Map functional to anatomical without resampling. Rather, change
the vox2ras (sform/qform) matrix. This is the same cmd line as 1.A,
but --no-resample as been added.

mri_vol2vol --reg register.dat --mov f.nii.gz --fstarg \\
   --o f.new.vox2ras.nii.gz --no-resample

f.new.vox2ras.nii.gz will have the same dimension and voxel size
as f.nii.gz, but its vox2ras (sform/qform) matrix will have changed.
You can check the registration in two ways:

  # The registration is created implicitly from the vox2ras matrix
  # (that is what --regheader does). There's no need to specify
  # and input registration
  tkregister2 --mov f.new.vox2ras.nii.gz --s bert --regheader --reg /tmp/reg

  # Display the functional as an overlay in tkmedit (no registration
  # needed).
  tkmedit bert orig.mgz -overlay f.new.vox2ras.nii.gz

1.D Map a binary mask in functional space to anatomical space. This is
basically the same cmd line as 1.A, but --interp nearest has been
added so that it does not try to interpolate the mask (ie, it will
still be binary after resampling):

mri_vol2vol --reg register.dat --mov mask.nii.gz --fstarg \\
   --o mask-in-anat.mgh --interp nearest

2. Map functional to/from talairach (MNI305) space. This uses a
two-stage registration: func-to-anat (register.dat) and
anat-to-talairach (talairach.xfm).

Make sure that sure the func-to-anat reg is correct as was done in
Example 1. Next, make sure that the anat-to-tal is correct with:

tkregister2 --s bert --fstal

2.A Map functional to talairach (MNI305) space with 2mm isotropic
resolution. This is very similar to 1.A with the addition of --tal
and --talres 2.

mri_vol2vol --mov f.nii.gz --reg register.dat \\
     --o f-in-tal.2mm.mgh --tal --talres 2

f-in-tal.2mm.mgh will be 2mm isotropic with the same geometry as
$FREESURFER_HOME/average/mni305.cor.subfov2.mgz. This command will
also create f-in-tal.2mm.mgh.reg, which will register the volume with
any average MNI305 FreeSurfer subject (fsaverage is used by default).
The resampling can be checked with:

  # This will show the functional with the fsaverage anatomical
  tkregister2 --mov f-in-tal.2mm.mgh --reg f-in-tal.2mm.mgh.reg

2.B Map functional to talairach (MNI305) space with 1mm isotropic
resolution. Same as 2.A but use --talres 1.

mri_vol2vol --mov f.nii.gz --reg register.dat \\
     --o f-in-tal.1mm.mgh --tal --talres 1

f-in-tal.1mm.mgh will take up 8 times as much space as f-in-tal.2mm.mgh

3. Apply an MNI transform to data by resampling the anatomical orig.mgz
into talairach space using bert/mri/transforms/talairach.xfm:

First, check that the talairach.xfm is correct (this is basically the same
thing as 'tkregister2 --s bert --fstal' in Example 2:

 cd bert/mri
 tkregister2 --targ orig.mgz \\
     --mov $FREESURFER_HOME/average/mni305.cor.mgz \\
     --xfm transforms/talairach.xfm --reg /tmp/reg

 Now resample
 mri_vol2vol --mov orig.mgz \\
     --targ $FREESURFER_HOME/average/mni305.cor.mgz \\
     --xfm transforms/talairach.xfm  \\
     --o orig-in-mni305.mgz

 Now test the resampling:
 tkregister2 --mov orig-in-mni305.mgz \\
    --targ $FREESURFER_HOME/average/mni305.cor.mgz \\
    --reg /tmp/reg --regheader


FORMATS

Data file format can be specified implicitly (through the path name)
or explicitly. All formats accepted by mri_convert can be used.

BUGS

sinc interpolation is broken except for maybe COR to COR.


BUG REPORTING

Report bugs to analysis-bugs@nmr.mgh.harvard.edu. Include the following
formatted as a list as follows: (1) command-line, (2) directory where
the program was run (for those in the MGH-NMR Center), (3) version,
(4) text output, (5) description of the problem.

SEE ALSO

mri_convert, tkregister2


ENDHELP --------------------------------------------------------------

*/

#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <unistd.h>
#include <string.h>
#include <sys/stat.h>
#include <sys/types.h>

#include "macros.h"
#include "error.h"
#include "diag.h"
#include "proto.h"

#include "matrix.h"
#include "mri.h"
#include "version.h"
#include "mri2.h"
#include "mri_identify.h"
#include "MRIio_old.h"
#include "registerio.h"
#include "resample.h"
#include "transform.h"
#include "gca.h"
#include "gcamorph.h"
#include "fio.h"
#include "pdf.h"
#include "cmdargs.h"

#include "chronometer.h"

#ifdef FS_CUDA
#include "devicemanagement.h"
#include "mrivol2vol_cuda.h"
#endif



#ifdef X
#undef X
#endif

// For some reason, this does not seemed to be defined in math.h
double round(double x);

static int  parse_commandline(int argc, char **argv);
static void check_options(void);
static void print_usage(void) ;
static void usage_exit(void);
static void print_help(void) ;
static void print_version(void) ;
static void argnerr(char *option, int n);
static void dump_options(FILE *fp);
static int  singledash(char *flag);
static int isflag(char *flag);
static int nth_is_arg(int nargc, char **argv, int nth);
#include "tags.h"
static int istringnmatch(char *str1, char *str2, int n);
static MATRIX *LoadRtal(int talres);
MATRIX *LoadRfsl(char *fname);

int main(int argc, char *argv[]) ;

static char vcid[] = "$Id: mri_vol2vol.c,v 1.63.2.1 2010/08/04 18:14:42 nicks Exp $";
char *Progname = NULL;

int debug = 0, gdiagno = -1;

char *movvolfile=NULL;
char *targvolfile=NULL;
int  fstarg = 0;
char *fstargfile = "orig.mgz";
char *outvolfile=NULL, *outdir=NULL;
char *regfile=NULL;
char *xfmfile=NULL;
char *fslregfile=NULL;
char *tempvolfile=NULL;
int  invert=0;
int  fstal=0;
int  fstalres = 2; // Can only be 1 or 2
char *precision = "float";
int   precisioncode = MRI_FLOAT;
char *interpmethod = "trilinear";
int   interpcode = 0;
int   sinchw;
int   regheader=0;
int   noresample=0;

MRI *mov, *targ, *out;
MRI *in, *template;
MRI *tmpmri;

MATRIX *R=NULL, *R2=NULL, *invR, *XFM;
MATRIX *vox2vox, *vox2ras;
MATRIX *Xtal,*invXtal,*Rtal,*invRtal;
MATRIX *Tin, *invTin, *Sin, *invSin;
MATRIX *Ttemp, *invTtemp, *Stemp, *invStemp;
MATRIX *Rfsl, *Rfsl2;

char *FSH=NULL;
char *SUBJECTS_DIR=NULL;
char *talxfmfile = "talairach.xfm";

char *talsubject = NULL;
char *subject = NULL;
char *subject_outreg = NULL;

int dont_irescale = 1;
float minrescale = 0.0, maxrescale = 255.0;

float ipr, bpr, intensity;
int float2int,err, nargs;
int SaveReg=1;

int DoKernel = 0;
int DoSaveInputMR = 1 ; // this is now the default behavior
int DoDelta  = 0;

char tmpstr[2000];

int DoMorph = 0;
int InvertMorph = 0;
TRANSFORM *Rtransform;  //types : M3D, M3Z, LTA, FSLMAT, DAT, OCT(TA), XFM
GCAM      *gcam;
char gcamfile[1000];
MRI_REGION region;
char *m3zfile = "talairach.m3z";

double angles[3] = {0,0,0};
MATRIX *Mrot = NULL;
double xyztrans[3] = {0,0,0};
MATRIX *Mtrans = NULL;
double shear[3] = {0,0,0};
MATRIX *Mshear = NULL;

char *SegRegCostFile = NULL;
char  *fspec;
MRI *regseg;
int CostOnly = 0;
char *RegFileFinal=NULL;

int SynthSeed = -1;
int synth = 0;
int DoCrop = 0;
double CropScale = 0;

char *DispFile = NULL;
MRI *DispMap = NULL;

int slice_crop_flag = 0;
int slice_crop_start, slice_crop_stop;
int SliceReverse = 0;
int SliceBias  = 0;
double SliceBiasAlpha = 1.0;

int useold = 1;
MRI *vsm = NULL;
char *vsmvolfile=NULL;

/*---------------------------------------------------------------*/
int main(int argc, char **argv) {
  char regfile0[1000];
  char cmdline[CMD_LINE_LEN] ;
  double costs[8];
  FILE *fp;
  int n,err;
  MRI *crop, *cropnew, *mri;
  MRI_REGION box;

#ifdef FS_CUDA
  AcquireCUDADevice();
#endif


  make_cmd_version_string(argc, argv,
                          "$Id: mri_vol2vol.c,v 1.63.2.1 2010/08/04 18:14:42 nicks Exp $",
                          "$Name:  $", cmdline);

  /* rkt: check for and handle version tag */
  nargs = handle_version_option(argc, argv,
                                "$Id: mri_vol2vol.c,v 1.63.2.1 2010/08/04 18:14:42 nicks Exp $",
                                "$Name:  $");
  if(nargs && argc - nargs == 1) exit (0);

  Progname = argv[0] ;
  argc --;
  argv++;
  ErrorInit(NULL, NULL, NULL) ;
  DiagInit(NULL, NULL, NULL) ;

  FSH = getenv("FREESURFER_HOME");
  if(FSH==NULL) {
    printf("ERROR: FREESURFER_HOME undefined.\n");
    exit(1);
  }
  if(argc == 0) usage_exit();

  parse_commandline(argc, argv);
  if(gdiagno > -1) Gdiag_no = gdiagno;
  check_options();

  // Seed the random number generator just in case
  if (SynthSeed < 0) SynthSeed = PDFtodSeed();
  srand48(SynthSeed);

  dump_options(stdout);

  if(DoCrop){
    printf("Crop %lf\n",CropScale);
    mov = MRIread(movvolfile);
    if(mov == NULL) exit(1);
    err = MRIboundingBox(mov, 0.5, &box);
    if(err) exit(1);
    crop  = MRIcrop(mov,box.x, box.y, box.z,
		    box.x+box.dx, box.y+box.dy, box.z+box.dz);
    //MRIwrite(crop,"crop.mgh");

    cropnew = MRIalloc(nint(crop->width*CropScale),
		       nint(crop->height*CropScale),
		       nint(crop->depth*CropScale),
		       mov->type);
    cropnew->x_r = crop->x_r;
    cropnew->x_a = crop->x_a;
    cropnew->x_s = crop->x_s;

    cropnew->y_r = crop->y_r;
    cropnew->y_a = crop->y_a;
    cropnew->y_s = crop->y_s;

    cropnew->z_r = crop->z_r;
    cropnew->z_a = crop->z_a;
    cropnew->z_s = crop->z_s;

    cropnew->c_r = crop->c_r;
    cropnew->c_a = crop->c_a;
    cropnew->c_s = crop->c_s;

    cropnew->xsize = crop->xsize/CropScale;
    cropnew->ysize = crop->ysize/CropScale;
    cropnew->zsize = crop->zsize/CropScale;

    printf("vol2vol\n");
    err = MRIvol2Vol(crop,cropnew,NULL,SAMPLE_NEAREST,0);
    if(err) exit(1);
    printf("Saving\n");
    err = MRIwrite(cropnew,outvolfile);
    printf("mri_vol2vol done\n");
    exit(err);
  }

  /*-----------------------------------------------------*/
  if (fstal) {
    // Recompute R for converting to/from talairach space
    // and set the target volume file
    printf("Compute R for talairach space\n");
    Xtal = DevolveXFM(subject, NULL, talxfmfile);
    invXtal = MatrixInverse(Xtal,NULL);
    if (Xtal == NULL) exit(1);
    if (fstalres > 0) {
      Rtal = LoadRtal(fstalres);
      sprintf(tmpstr,"%s/average/mni305.cor.subfov%d.mgz",FSH,fstalres);
      targvolfile = strcpyalloc(tmpstr);
    } else {
      Rtal = MatrixIdentity(4,NULL);
      sprintf(tmpstr,"%s/average/mni305.cor.mgz",FSH);
      targvolfile = strcpyalloc(tmpstr);
    }
    invRtal = MatrixInverse(Rtal,NULL);
    if (Gdiag_no > 0) {
      printf("matrix from regfile ---------------------- \n");
      MatrixPrint(stdout,R);
      printf("Xtal ---------------------- \n");
      MatrixPrint(stdout,Xtal);
      printf("Rtal ---------------------- \n");
      MatrixPrint(stdout,Rtal);
    }
    // Recompute: R = R*inv(Xtal)*inv(Rtal)
    R = MatrixMultiply(R,invXtal,R);
    R = MatrixMultiply(R,invRtal,R);
  }

  if(!invert) {
    // dont invert
    mov = MRIread(movvolfile);
    if (mov == NULL) exit(1);
    targ = MRIreadHeader(targvolfile,MRI_VOLUME_TYPE_UNKNOWN);
    if (targ == NULL) exit(1);
    in = mov;
    template = targ;
    tempvolfile = targvolfile;
  }
  else{
    //invert
    mov = MRIreadHeader(movvolfile,MRI_VOLUME_TYPE_UNKNOWN);
    if(mov == NULL) exit(1);
    targ = MRIread(targvolfile);
    if(targ == NULL) exit(1);
    in = targ;
    template = mov;
    tempvolfile = movvolfile;
  }
  if(synth) {
    printf("Replacing input data with synthetic white noise\n");
    MRIrandn(in->width,in->height,in->depth,in->nframes,0,1,in);
  }

  if(regheader) {
    printf("Computing registration based on scanner-to-scanner\n");
    R = MRItkRegMtx(targ,mov,XFM);
  }

  if(fslregfile) {
    printf("Computing registration based on fsl registration\n");
    R = MRIfsl2TkReg(targ, mov, Rfsl);
    if(Rfsl2) R2 = MRIfsl2TkReg(targ, mov, Rfsl2);
  }

  if(R == NULL)
    ErrorExit(ERROR_BADPARM, "ERROR: no registration specified\n") ;


  if(R2){
    R = MatrixSubtract(R,R2,R);
    for(n=1; n<4; n++) R->rptr[n][n] += 1.0;
  }

  if(Mrot){
    printf("Applying rotation matrix (R=M*R)\n");
    printf("Current Reg Matrix is:\n");
    MatrixPrint(stdout,R);
    printf("  Angles (deg): %lf %lf %lf\n",angles[0]*180/M_PI,angles[1]*180/M_PI,angles[2]*180/M_PI);
    printf("  Angles (rad): %lf %lf %lf\n",angles[0],angles[1],angles[2]);
    printf("  Rotation matrix:\n");
    MatrixPrint(stdout,Mrot);
    R = MatrixMultiply(Mrot,R,R);
  }

  if(Mtrans){
    printf("Applying translation matrix (R=M*R)\n");
    printf("Current Reg Matrix is:\n");
    MatrixPrint(stdout,R);
    printf("  Trans (mm): %lf %lf %lf\n",xyztrans[0],xyztrans[1],xyztrans[2]);
    printf("  Translation matrix:\n");
    MatrixPrint(stdout,Mtrans);
    R = MatrixMultiply(Mtrans,R,R);
  }
  if(Mshear){
    printf("Applying shear matrix (R=M*R)\n");
    printf("Current Reg Matrix is:\n");
    MatrixPrint(stdout,R);
    printf("  Shear: %lf %lf %lf\n",shear[0],shear[1],shear[2]);
    printf("  Shear matrix:\n");
    MatrixPrint(stdout,Mshear);
    R = MatrixMultiply(Mshear,R,R);
  }

  if(RegFileFinal){
    printf("Writing final tkRAS-to-tkRAS Matrix to %s\n",RegFileFinal);
    regio_write_register(RegFileFinal,subject,in->xsize,
			 in->zsize,1,R,FLT2INT_ROUND);
  }

  if(invert) {
    printf("Inverting registration\n");
    R = MatrixInverse(R,NULL);
  }

  printf("\n");
  printf("Final tkRAS-to-tkRAS Matrix is:\n");
  MatrixPrint(stdout,R);
  printf("\n");

  if(DispFile){
    printf("Computing affine displacment\n");
    DispMap = MRIaffineDisplacment(in, R);
    MRIwrite(DispMap,DispFile);
    if(outvolfile == NULL) {
      printf("No other output specified, so exiting now\n");
      exit(0);
    }
  }

  invR = MatrixInverse(R,NULL);

  // Vox-to-tkRAS Matrices
  Tin      = MRIxfmCRS2XYZtkreg(in);
  invTin   = MatrixInverse(Tin,NULL);
  Ttemp    = MRIxfmCRS2XYZtkreg(template);
  invTtemp = MatrixInverse(Ttemp,NULL);

  // Vox-to-ScannerRAS Matrices
  Sin      = MRIxfmCRS2XYZ(in,0);
  invSin   = MatrixInverse(Sin,NULL);
  Stemp    = MRIxfmCRS2XYZ(template,0);
  invStemp = MatrixInverse(Stemp,NULL);

  if(noresample) {
    printf("Not resampling, only changing vox2ras matrix\n");
    // Compte new vox2ras instead of resampling
    // vox2ras = Stemp * invTtemp * invR * Tin
    vox2ras = MatrixMultiply(Stemp,invTtemp,NULL);
    MatrixMultiply(vox2ras,invR,vox2ras);
    MatrixMultiply(vox2ras,Tin,vox2ras);
    MRIsetVoxelToRasXform(in,vox2ras);
    if(slice_crop_flag){
      printf("Cropping slices from %d to %d\n",slice_crop_start,slice_crop_stop);
      crop  = MRIcrop(in, 0, 0, slice_crop_start,
		      in->width-1, in->height-1,slice_crop_stop);
      if(crop == NULL) exit(1);
      MRIfree(&in);
      in = crop;
    }
    if(SliceReverse){
      printf("Reversing slices, updating vox2ras\n");
      mri = MRIreverseSlices(in, NULL);
      if(mri == NULL) exit(1);
      MRIfree(&in);
      in = mri;
    }
    if(SliceBias){
      printf("Applying Half-Cosine Slice Bias, Alpha = %g\n",SliceBiasAlpha);
      MRIhalfCosBias(in, SliceBiasAlpha, in);
    }
    err = MRIwrite(in,outvolfile);
    if(err){
      printf("ERROR: writing %s\n",outvolfile);
      exit(1);
    }
    printf("To check registration, run:\n");
    printf("\n");
    printf("  tkregister2 --mov %s --targ %s --regheader --reg /tmp/reg \n",
           outvolfile,tempvolfile);
    printf("\n");
    printf("mri_vol2vol done\n");
    return(0);
  }

  // Only gets here if resampling
  // vox2vox converts a template vox to input vox
  // vox2vox = invTin * R * Ttemp
  vox2vox = MatrixMultiply(invTin,R,NULL);
  MatrixMultiply(vox2vox,Ttemp,vox2vox);

  printf("\n");
  printf("Vox2Vox Matrix is:\n");
  MatrixPrint(stdout,vox2vox);
  printf("\n");

  // Allocate the output
  template->type = precisioncode;
  if (DoSaveInputMR)  // it is now on by default
  {
    template->tr = in->tr ;
    template->ti = in->ti ;
    template->flip_angle = in->flip_angle ;
    template->te = in->te ;

  }
  if (!DoMorph) {
    if(DoKernel) {
      out = MRIcloneBySpace(template,MRI_FLOAT,8);
      printf("Computing Trilinear Kernel\n");
      MRIvol2VolTLKernel(in,out,vox2vox);
    } else if(DoDelta) {
      printf("Computing Delta\n");
      out = MRIvol2VolDelta(in,template,R);
    } else {
      out = MRIcloneBySpace(template,-1,in->nframes);
      printf("Resampling\n");
      if(useold) MRIvol2Vol(in,out,vox2vox,interpcode,sinchw);
      if(!useold){
	if(vsmvolfile){
	  printf("Reading %s\n",vsmvolfile);
	  vsm = MRIread(vsmvolfile);
	  if(vsm == NULL) exit(1);
	}
	MRIvol2VolVSM(in,out,vox2vox,interpcode,sinchw,vsm);
      }
    }
  }
  else {
    Rtransform = (TRANSFORM *)calloc(sizeof(TRANSFORM),1);
    Rtransform->xform = (void *)TransformRegDat2LTA(template, mov, R);

    printf("Reading gcam\n");
    sprintf(gcamfile,"%s/%s/mri/transforms/%s",
	    SUBJECTS_DIR,subject,m3zfile);
    if(! InvertMorph){
      //mri_vol2vol --mov orig.mgz --morph --s subject --o orig.morphed.mgz
      gcam = GCAMread(gcamfile);
      if(gcam == NULL) exit(1);
      printf("Applying reg to gcam\n");
      GCAMapplyTransform(gcam, Rtransform);  //voxel2voxel
      printf("Applying morph to input\n");
      out = GCAMmorphToAtlas(in, gcam, NULL, -1, interpcode);
    }
    else{
      //mri_vol2vol --mov orig.morphed.mgz --inv-morph --s subject --o origB.mgz
      gcam = GCAMreadAndInvert(gcamfile);
      if(gcam == NULL) exit(1);
      printf("Applying reg to gcam\n");
      GCAMapplyTransform(gcam, Rtransform);  //voxel2voxel
      if(in->type != MRI_UCHAR){
	printf("Changing type to uchar\n");
	tmpmri = MRISeqchangeType(in, MRI_UCHAR, 0 , 255, 1);
	MRIfree(&in);
	in = tmpmri;
      }
      printf("Applying inverse morph to input\n");
      out = GCAMmorphFromAtlas(in, gcam, NULL, SAMPLE_TRILINEAR);
    }
    if(out == NULL) exit(1);

    if(0){
    printf("Extracting region\n");
    region.x = 51;
    region.y = 0;
    region.z = 11;
    region.dx = 156;
    region.dy = 216;
    region.dz = 240;
    tmpmri = MRIextractRegion(out, NULL, &region) ;
    MRIfree(&out);
    out = tmpmri;
    }
  }

  if(SegRegCostFile){
    sprintf(tmpstr,"%s/%s/mri/regseg",SUBJECTS_DIR,subject);
    fspec = IDnameFromStem(tmpstr);
    regseg = MRIread(fspec);
    if(regseg == NULL) exit(1);
    free(fspec);
    SegRegCost(regseg,out,costs);
    fp = fopen(SegRegCostFile,"a");
    for(n=0; n<3; n++) fprintf(fp,"%7.3lf ",xyztrans[n]);
    for(n=0; n<3; n++) fprintf(fp,"%5.1lf ",angles[n]*180/M_PI);
    fprintf(fp,"%7d %10.4lf %8.4lf ",(int)costs[0],costs[1],costs[2]); // WM  n mean std
    fprintf(fp,"%7d %10.4lf %8.4lf ",(int)costs[3],costs[4],costs[5]); // CTX n mean std
    fprintf(fp,"%8.4lf %8.4lf ",costs[6],costs[7]); // t, cost=1/t
    fprintf(fp,"\n");
    fclose(fp);
    if(CostOnly) exit(0);
  }

  if(slice_crop_flag){
    printf("Cropping slices from %d to %d\n",slice_crop_start,slice_crop_stop);
    crop  = MRIcrop(out, 0, 0, slice_crop_start,
		    out->width-1, out->height-1,slice_crop_stop);
    if(crop == NULL) exit(1);
    MRIfree(&out);
    out = crop;
  }
  err = MRIwrite(out,outvolfile);
  if(err){
    printf("ERROR: writing %s\n",outvolfile);
    exit(1);
  }

  sprintf(regfile0,"%s.reg",outvolfile);
  printf("INFO: writing registration matrix to %s\n",regfile0);
  if(fstal) {
    R = Rtal;
    subject_outreg = "fsaverage";
  }
  else{
    R = MatrixIdentity(4,NULL);
    if(subject != NULL) subject_outreg = subject;
    else                subject_outreg = "subject-unknown";
    printf("Output registration matrix is identity\n");
  }

  if(SaveReg) {
    regio_write_register(regfile0,subject_outreg,out->xsize,
                         out->zsize,1,R,FLT2INT_ROUND);
    printf("To check registration, run:\n");
    printf("\n");
    if (!fstal) {
      printf("  tkregister2 --mov %s --targ %s --reg %s \n",
             outvolfile,tempvolfile,regfile0);
    }  else {
      printf("  tkregister2 --s %s --surf white --reg %s --mov %s \n",
             subject_outreg,regfile0,outvolfile);
    }
  }

  printf("\n");
  printf("mri_vol2vol done\n");

#ifdef FS_CUDA
  PrintGPUtimers();
#endif

  return(0);
}


/* ------------------------------------------------------------------ */
/* ------------------------------------------------------------------ */
/* ------------------------------------------------------------------ */
static int parse_commandline(int argc, char **argv) {
  int  nargc , nargsused;
  char **pargv, *option ;
  int err;

  if (argc < 1) usage_exit();

  nargc   = argc;
  pargv = argv;
  while (nargc > 0) {

    option = pargv[0];
    if (debug) printf("%d %s\n",nargc,option);
    nargc -= 1;
    pargv += 1;

    nargsused = 0;

    if (!strcasecmp(option,      "--help"))     print_help() ;
    else if (!strcasecmp(option, "--version"))  print_version() ;
    else if (!strcasecmp(option, "--debug"))    debug = 1;
    else if (!strcasecmp(option, "--tal"))      fstal = 1;
    else if (!strcasecmp(option, "--inv"))      invert = 1;
    else if (!strcasecmp(option, "--no-resample")) noresample = 1;
    else if (!strcasecmp(option, "--regheader")) regheader = 1;
    else if (!strcasecmp(option, "--kernel"))    DoKernel = 1;
    else if (!strcasecmp(option, "--nomr"))      DoSaveInputMR = 1;
    else if (!strcasecmp(option, "--mr"))        DoSaveInputMR = 0;
    else if (!strcasecmp(option, "--delta"))     DoDelta = 1;
    else if (!strcasecmp(option, "--no-save-reg"))  SaveReg = 0;
    else if (!strcasecmp(option, "--cost-only"))  CostOnly = 1;
    else if (!strcasecmp(option, "--synth"))   synth = 1;
    else if (!strcasecmp(option, "--new"))   useold = 0;
    else if (!strcasecmp(option, "--morph")) {
      DoMorph = 1;
      fstarg = 1;
    } 
    else if (!strcasecmp(option, "--fstarg")){
      fstarg = 1;
      if(CMDnthIsArg(nargc, pargv, 0)){
        fstargfile = pargv[0];
        nargsused = 1;
      } 
      printf("fstargfile %s\n",fstargfile);
    }
    else if (!strcasecmp(option, "--inv-morph")) {
      DoMorph = 1;
      InvertMorph = 1;
      fstarg = 1;
    } else if (istringnmatch(option, "--m3z",0)) {
      if (nargc < 1) argnerr(option,1);
      m3zfile = pargv[0]; DoMorph = 1;
      nargsused = 1;
    } else if (istringnmatch(option, "--mov",0)) {
      if (nargc < 1) argnerr(option,1);
      movvolfile = pargv[0];
      nargsused = 1;
    } else if (istringnmatch(option, "--vsm",0)) {
      if (nargc < 1) argnerr(option,1);
      vsmvolfile = pargv[0];
      useold = 0;
      nargsused = 1;
    } else if (istringnmatch(option, "--targ",0)) {
      if (nargc < 1) argnerr(option,1);
      targvolfile = pargv[0];
      nargsused = 1;
    } 
    else if (istringnmatch(option, "--reg",0)) {
      if (nargc < 1) argnerr(option,1);
      regfile = pargv[0];
      err = regio_read_register(regfile, &subject, &ipr, &bpr,
                                &intensity, &R, &float2int);
      if (err) exit(1);
      nargsused = 1;
    } 
    else if (istringnmatch(option, "--mni152reg",0)) {
      sprintf(tmpstr,"%s/average/mni152.register.dat",getenv("FREESURFER_HOME"));
      regfile = strcpyalloc(tmpstr);
      err = regio_read_register(regfile, &subject, &ipr, &bpr,
                                &intensity, &R, &float2int);
      if (err) exit(1);
    } 
    else if (istringnmatch(option, "--reg-final",0)) {
      if (nargc < 1) argnerr(option,1);
      RegFileFinal = pargv[0];
      nargsused = 1;
    } else if (istringnmatch(option, "--s",0)) {
      if (nargc < 1) argnerr(option,1);
      subject = pargv[0];
      R = MatrixIdentity(4,NULL);
      nargsused = 1;
    } else if (istringnmatch(option, "--fsl",0) ||
               istringnmatch(option, "--fslreg",0)) {
      if(nargc < 1) argnerr(option,1);
      fslregfile = pargv[0];
      Rfsl = LoadRfsl(fslregfile);
      if(Rfsl == NULL) exit(1);
      nargsused = 1;
      if(nargc > 1 && !CMDisFlag(pargv[1])){
	Rfsl2 = LoadRfsl(pargv[1]);
	if(Rfsl2 == NULL) exit(1);
	nargsused++;
      }
    } else if (istringnmatch(option, "--xfm",0)) {
      if (nargc < 1) argnerr(option,1);
      xfmfile = pargv[0];
      err = regio_read_mincxfm(xfmfile, &XFM, NULL);
      if (err) exit(1);
      regheader = 1;
      nargsused = 1;
    } else if (istringnmatch(option, "--talxfm",0)) {
      if (nargc < 1) argnerr(option,1);
      talxfmfile = pargv[0];
      fstal = 1;
      nargsused = 1;
    } 
    else if (istringnmatch(option, "--out",0) ||
               istringnmatch(option, "--o",0)) {
      if (nargc < 1) argnerr(option,1);
      outvolfile = pargv[0];
      nargsused = 1;
    } 
    else if (istringnmatch(option, "--disp",0)){
      if(nargc < 1) argnerr(option,1);
      DispFile = pargv[0];
      nargsused = 1;
    } 
    else if (istringnmatch(option, "--talres",8)) {
      if (nargc < 1) argnerr(option,1);
      sscanf(pargv[0],"%d",&fstalres);
      if (fstalres != 1 && fstalres != 2) {
        printf("ERROR: tal res %d invalid. Only use 1 or 2\n",fstalres);
        exit(1);
      }
      nargsused = 1;
    } else if (istringnmatch(option, "--crop",6)) {
      if (nargc < 1) argnerr(option,1);
      sscanf(pargv[0],"%lf",&CropScale);
      DoCrop = 1;
      nargsused = 1;
    } else if(istringnmatch(option, "--slice-crop",12)) {
      if(nargc < 2) argnerr(option,2);
      slice_crop_flag = 1;
      sscanf(pargv[0],"%d",&slice_crop_start);
      sscanf(pargv[1],"%d",&slice_crop_stop);
      nargsused = 2;
    } 
    else if(istringnmatch(option, "--slice-reverse",0)) SliceReverse = 1;
    else if(istringnmatch(option, "--slice-bias",0)){
      if(nargc < 1) argnerr(option,1);
      sscanf(pargv[0],"%lf",&SliceBiasAlpha);
      SliceBias = 1;
      nargsused = 1;
    }
    else if (istringnmatch(option, "--interp",8)) {
      if (nargc < 1) argnerr(option,1);
      interpmethod = pargv[0];
      nargsused = 1;
      if (!strcmp(interpmethod,"sinc") && nth_is_arg(nargc, pargv, 1)) {
        sscanf(pargv[1],"%d",&sinchw);
        nargsused ++;
      }
    } 
    else if (istringnmatch(option, "--trilin",6)) {
      interpmethod = "trilinear";
    } 
    else if (istringnmatch(option, "--nearest",7)) {
      interpmethod = "nearest";
    } 
    else if (istringnmatch(option, "--precision",0)) {
      if (nargc < 1) argnerr(option,1);
      precision = pargv[0];
      precisioncode = MRIprecisionCode(precision);
      if (precisioncode < 0) {
        printf("ERROR: precision %s unrecognized\n",precision);
        printf("       legal values are uchar, short, int, long, and float\n");
        exit(1);
      }
      nargsused = 1;
    } else if (!strcasecmp(option, "--seed")) {
      if (nargc < 1) CMDargNErr(option,1);
      sscanf(pargv[0],"%d",&SynthSeed);
      synth = 1;
      nargsused = 1;
    } else if (istringnmatch(option, "--sd",4)) {
      if (nargc < 1) argnerr(option,1);
      setenv("SUBJECTS_DIR",pargv[0],1);
      nargsused = 1;
    } else if (istringnmatch(option, "--rot",0)) {
      if (nargc < 3) argnerr(option,3);
      // Angles are in degrees
      sscanf(pargv[0],"%lf",&angles[0]);
      sscanf(pargv[1],"%lf",&angles[1]);
      sscanf(pargv[2],"%lf",&angles[2]);
      angles[0] *= (M_PI/180);
      angles[1] *= (M_PI/180);
      angles[2] *= (M_PI/180);
      Mrot = MRIangles2RotMat(angles);
      nargsused = 3;
    } else if (istringnmatch(option, "--trans",0)) {
      if (nargc < 3) argnerr(option,3);
      // Translation in mm
      sscanf(pargv[0],"%lf",&xyztrans[0]);
      sscanf(pargv[1],"%lf",&xyztrans[1]);
      sscanf(pargv[2],"%lf",&xyztrans[2]);
      Mtrans = MatrixIdentity(4,NULL);
      Mtrans->rptr[1][4] = xyztrans[0];
      Mtrans->rptr[2][4] = xyztrans[1];
      Mtrans->rptr[3][4] = xyztrans[2];
      nargsused = 3;
    } else if (istringnmatch(option, "--shear",0)) {
      if (nargc < 3) argnerr(option,3);
      // Shear
      sscanf(pargv[0],"%lf",&shear[0]);
      sscanf(pargv[1],"%lf",&shear[1]);
      sscanf(pargv[2],"%lf",&shear[2]);
      Mshear = MatrixIdentity(4,NULL);
      Mshear->rptr[1][2] = shear[0]; // xy/col-slice
      Mshear->rptr[1][3] = shear[1]; // xz/col-row - in-plane
      Mshear->rptr[2][3] = shear[2]; // yz/row-slice
      nargsused = 3;
    } else if ( !strcmp(option, "--gdiagno") ) {
      if (nargc < 1) argnerr(option,1);
      sscanf(pargv[0],"%d",&gdiagno);
      nargsused = 1;
    } else if (istringnmatch(option, "--subject",0)) {
      if (nargc < 1) argnerr(option,1);
      subject = pargv[0];
      nargsused = 1;
    } else if (istringnmatch(option, "--cost",0)) {
      if (nargc < 1) argnerr(option,1);
      SegRegCostFile = pargv[0];
      nargsused = 1;
    } else {
      fprintf(stderr,"ERROR: Option %s unknown\n",option);
      if (singledash(option))
        fprintf(stderr,"       Did you really mean -%s ?\n",option);
      exit(-1);
    }
    nargc -= nargsused;
    pargv += nargsused;
  }
  return(0);
}
/* ------------------------------------------------------ */
static void usage_exit(void) {
  print_usage() ;
  exit(1) ;
}
/* --------------------------------------------- */
static void print_usage(void) {
printf("\n");
printf("mri_vol2vol\n");
printf("\n");
printf("  --mov  movvol       : input (or output template with --inv)\n");
printf("  --targ targvol      : output template (or input with --inv)\n");
printf("  --o    outvol       : output volume\n");
printf("  --disp dispvol      : displacement volume\n");
printf("\n");
printf("  --reg  register.dat : tkRAS-to-tkRAS matrix   (tkregister2 format)\n");
printf("  --fsl  register.fsl : fslRAS-to-fslRAS matrix (FSL format)\n");
printf("  --xfm  register.xfm : ScannerRAS-to-ScannerRAS matrix (MNI format)\n");
printf("  --regheader         : ScannerRAS-to-ScannerRAS matrix = identity\n");
printf("  --mni152reg         : $FREESURFER_HOME/average/mni152.register.dat\n");
printf("  --s subject         : set matrix = identity and use subject for any templates\n");
printf("\n");
printf("  --inv               : sample from targ to mov\n");
printf("\n");
printf("  --tal               : map to a sub FOV of MNI305 (with --reg only)\n");
printf("  --talres resolution : set voxel size 1mm or 2mm (def is 1)\n");
printf("  --talxfm xfmfile    : default is talairach.xfm (looks in mri/transforms)\n");
printf("\n");
printf("  --fstarg <vol>      : use vol <orig.mgz> from subject in --reg as target\n");
printf("  --crop scale        : crop and change voxel size\n");
printf("  --slice-crop sS sE  : crop output slices to be within sS and sE\n");
printf("  --slice-reverse     : reverse order of slices, update vox2ras\n");
printf("  --slice-bias alpha  : apply half-cosine bias field\n");
printf("\n");
printf("  --trilin            : trilinear interpolation (default)\n");
printf("  --nearest           : nearest neighbor interpolation\n");
printf("  --interp interptype : interpolation trilin or nearest (def is trilin)\n");
printf("\n");
printf("  --precision precisionid : output precision (def is float)\n");
printf("  --kernel            : save the trilinear interpolation kernel instead\n");
printf("\n");
printf("  --no-resample : do not resample, just change vox2ras matrix\n");
printf("\n");
printf("  --rot   Ax Ay Az : rotation angles (deg) to apply to reg matrix\n");
printf("  --trans Tx Ty Tz : translation (mm) to apply to reg matrix\n");
printf("  --shear Sxy Sxz Syz : xz is in-plane\n");
printf("  --reg-final regfinal.dat : final reg after rot and trans (but not inv)\n");
printf("\n");
printf("  --synth : replace input with white gaussian noise\n");
printf("  --seed seed : seed for synth (def is to set from time of day)\n");
printf("\n");
printf("  --no-save-reg : do not write out output volume registration matrix\n");
printf("\n");
printf("  --help : go ahead, make my day\n");
printf("  --debug\n");
printf("  --version\n");
printf("\n");
}
/* --------------------------------------------- */
static void print_help(void) {
  print_usage() ;
  printf("\n%s\n\n",vcid);
printf("\n");
printf("Resamples a volume into another field-of-view using various types of\n");
printf("matrices (FreeSurfer, FSL, SPM, and MNI). This is meant to be used\n");
printf("in conjunction with tkregister2.\n");
printf("\n");
printf("FLAGS AND ARGUMENTS\n");
printf("\n");
printf("--mov movvol\n");
printf("\n");
printf("This volume must have the same geometry as the --mov volume passed to\n");
printf("tkregister2 when creating/checking the registration file. By default,\n");
printf("this will be the input volume that will be resampled. If --inv is\n");
printf("specified, then this will become the geometry template for the output\n");
printf("instead.\n");
printf("\n");
printf("--targ targvol\n");
printf("\n");
printf("This volume must have the same geometry as the --targ volume passed to\n");
printf("tkregister2 when creating/checking the registration file. By default,\n");
printf("this will be the volume will be the geometry template for the output.\n");
printf("If --inv is specified, then this becomes the input volume that will be\n");
printf("resampled instead. The target volume can be implicitly specified with\n");
printf("--tal or --fstarg.\n");
printf("\n");
printf("--reg register.dat\n");
printf("\n");
printf("This simple text file contains the freesurfer registration matrix. It\n");
printf("is the same as the file passed to and generated by tkregister2 with\n");
printf("the --reg flag. If --tal or --fstarg is specified, then the subject\n");
printf("is obtained from the regfile.\n");
printf("\n");
printf("--fsl register.fsl\n");
printf("\n");
printf("Registration matrix created with the FSL flirt program using targ as\n");
printf("the reference and mov as input. Note: you cannot use any of the files\n");
printf("from $FSLDIR/etc/standard as mov or targ. These volumes do not have\n");
printf("geometry information in them, and FreeSurfer and FSL will default to\n");
printf("different things. Same as in tkregister2.\n");
printf("\n");
printf("--xfm register.xfm\n");
printf("\n");
printf("MNI-style registration matrix (eg, like one created with mritotal).\n");
printf("This matrix maps from mov Scanner-RAS to targ Scanner-RAS, where\n");
printf("'Scanner-RAS' is the vox2ras matrix as found in each file.\n");
printf("Same as in tkregister2.\n");
printf("\n");
printf("--regheader\n");
printf("\n");
printf("Create a registration matrix assuuming that the mov Scanner-RAS and\n");
printf("targ Scanner-RAS are the same. This is the same as using a register.xfm\n");
printf("with the identity matrix in it. This can be used with some SPM\n");
printf("registrations (which change only the matrix in the .mat file).\n");
printf("Same as in tkregister2.\n");
printf("\n");
printf("--inv\n");
printf("\n");
printf("Invert the transform. The movvol becomes the geometry template for the\n");
printf("output, and the targvol becomes the input that will be resampled.\n");
printf("\n");
printf("--o outvol\n");
printf("\n");
printf("Output volume.  By default, this will be the movvol resmapled into the\n");
printf("targvol space (and so will have the same geometry as the targvol). If\n");
printf("--inv is specified, then this will be the targvol resmapled into the\n");
printf("movvol space (and so will have the same geometry as the movvol). By\n");
printf("default, the output volume will be float, but this can be changed\n");
printf("with --precision. By default, the interpolation will be done with\n");
printf("trilinear, but this can be changed with --interp.\n");
printf("\n");
printf("--tal\n");
printf("\n");
printf("Resample the movvol to talairach (ie, MNI305) space. The talairach\n");
printf("matrix is obtained from talairach.xfm from\n");
printf("SUBJECTS_DIR/subjid/transforms. subjid is read from the register.dat\n");
printf("file. Requires --reg. Do not specify --targ as the target volume is\n");
printf("implicitly set to $FREESURFER_HOME/average/mni305.cor.subfovV.mgz,\n");
printf("where V is either 1 (for 1mm) or 2 (for 2mm). 2mm is used by default,\n");
printf("but this can be changed with --talres.  mni305.cor.subfovV.mgz the\n");
printf("MNI305 (1mm or 2mm isotropic) volume in a reduced FOV that covers only\n");
printf("the brain. Reducing the FOV saves space relative to the 256^3 COR FOV.\n");
printf("The transformation matrix is computed as R*inv(Xtal)*inv(Rtal), where\n");
printf("Xtal is talairach.xfm matrix, R is the matrix in the regfile, and Rtal\n");
printf("maps from the talairach COR FOV to the SubFOV (mni305.cor.subfovV.reg).\n");
printf("If you want to sample the targvol from talairach space into the movvol\n");
printf("space, then specify --inv. SUBJECTS_DIR is read from the environment\n");
printf("or can be specified with --sd.\n");
printf("\n");
printf("--fstalres resmm\n");
printf("\n");
printf("Set the resolution of the output when using --fstal. By default, it\n");
printf("is 2 mm, but can be changed to 1.0 mm with --fstalres 1\n");
printf("\n");
printf("--fstarg <vol>\n");
printf("\n");
printf("Set target to vol from the subject found in register.dat\n");
printf("file. If vol is not specified, uses orig.mgz. Requires --reg.  \n");
printf("Same as tkregister2.\n");
printf("\n");
printf("--crop scale\n");
printf("\n");
printf("Crop mov volume down to minimum size to fit non-zero voxels. The size of\n");
printf("the voxels is reduced by scale (ie, --crop 2 would crop and reduce the\n");
printf("voxel size by a factor of 2, eg 1.0 mm becomes 0.5 mm).\n");
printf("\n");
printf("--slice-crop start end\n");
printf("\n");
printf("Crop output volume to be within slices start and end. The geometry is \n");
printf("updated to reflect the new limits.\n");
printf("\n");
printf("--interp method\n");
printf("\n");
printf("Interpolate the output based on the given method. Legal values are:\n");
printf("trilin and nearest. trilin is the default. Can also use --trilin\n");
printf("or --nearest.\n");
printf("\n");
printf("--precision precisionid\n");
printf("\n");
printf("Set output precision to precisionid. Legal values are uchar, short,\n");
printf("int, long, and float. Default is float.\n");
printf("\n");
printf("--kernel\n");
printf("\n");
printf("Save the trilinear interpolation kernel at each voxel instead of the\n");
printf("interpolated image.\n");
printf("\n");
printf("--nomr\n");
printf("\n");
printf("Don't copy the template MR parameters, but instead preserve the input volume \n");
printf("ones\n");
printf("\n");
printf("--help\n");
printf("\n");
printf("Prints out all this information.\n");
printf("\n");
printf("--gdiagno diagnostic level\n");
printf("\n");
printf("Sets the diagnostic level (only good for debuggin').\n");
printf("\n");
printf("--version\n");
printf("\n");
printf("Print out version string and exit.\n");
printf("\n");
printf("\n");
printf("EXAMPLES:\n");
printf("\n");
printf("Below are some exampls of how one might use mri_vol2vol. They are not\n");
printf("exhaustive of all the possible combinations of options. Typically, one\n");
printf("uses a template to establish the registration, then resamples data\n");
printf("that are in correspondence with the template.\n");
printf("\n");
printf("1. If a functional volume is f.bhdr (or f.nii.gz, or f.mgh, etc), and the\n");
printf("subject is bert, and the registration file is register.dat, then\n");
printf("running the following command should show that they are in\n");
printf("registration:\n");
printf("\n");
printf("tkregister2 --reg register.dat --mov f.nii.gz\n");
printf("\n");
printf("If they are not, then fix it because nothing below is going to work. You\n");
printf("can also check the registration with:\n");
printf("\n");
printf("tkmedit bert orig.mgz  -overlay f.nii.gz -overlay-reg register.dat\n");
printf("\n");
printf("The register.dat will look something like this\n");
printf("----------------- register.dat --------------------------\n");
printf("bert\n");
printf("3.125\n");
printf("5.000\n");
printf("0.150000\n");
printf("1.000000e+00 0.000000e+00 0.000000e+00 -2.252487e+00\n");
printf("0.000000e+00 -8.902127e-01 4.555448e-01 2.342102e+00\n");
printf("0.000000e+00 4.555449e-01 8.902128e-01 -2.159538e-01\n");
printf("0.000000e+00 0.000000e+00 0.000000e+00 1.000000e+00\n");
printf("round\n");
printf("----------------- register.dat --------------------------\n");
printf("\n");
printf("1.A. To resample the functional into anatomical space:\n");
printf("\n");
printf("mri_vol2vol --reg register.dat --mov f.nii.gz --fstarg \\\n");
printf("   --o f-in-anat.mgh\n");
printf("\n");
printf("f-in-anat.mgh will have the same size and geometry as\n");
printf("bert/mri/orig.mgz.  You can test the result in two ways:\n");
printf("\n");
printf("  # This will show the low-res functional alighned with its resampled self\n");
printf("  tkregister2 --reg register.dat --mov f.nii.gz --targ f-in-anat.mgh\n");
printf("\n");
printf("  # This will show the resampled functional aligned with the anatomical\n");
printf("  tkregister2 --mov f-in-anat.mgh --targ $SUBJECTS_DIR/bert/mri/orig.mgz \\\n");
printf("     --regheader --reg /tmp/reg\n");
printf("\n");
printf("1.B. To resample the anatomical into the functional space. This is\n");
printf("basically the same command line as 1.A, but --inv has been included\n");
printf("and the name of the output is changed.\n");
printf("\n");
printf("mri_vol2vol --reg register.dat --mov f.nii.gz --fstarg \\\n");
printf("  --o anat-in-func.mgh --inv\n");
printf("\n");
printf("anat-in-func.mgh will be the same size and geometry as f.nii.gz.\n");
printf("You can test the result in two ways:\n");
printf("\n");
printf("  # This will show the low-res anat aligned with its hires self\n");
printf("  tkregister2 --reg register.dat --mov anat-in-func.mgh\n");
printf("\n");
printf("  # This will show the resampled anat aligned with the functional\n");
printf("  tkregister2 --mov anat-in-func.mgh --targ f.nii.gz \\\n");
printf("     --regheader --reg /tmp/reg\n");
printf("\n");
printf("1.C Map functional to anatomical without resampling. Rather, change\n");
printf("the vox2ras (sform/qform) matrix. This is the same cmd line as 1.A,\n");
printf("but --no-resample as been added.\n");
printf("\n");
printf("mri_vol2vol --reg register.dat --mov f.nii.gz --fstarg \\\n");
printf("   --o f.new.vox2ras.nii.gz --no-resample\n");
printf("\n");
printf("f.new.vox2ras.nii.gz will have the same dimension and voxel size\n");
printf("as f.nii.gz, but its vox2ras (sform/qform) matrix will have changed.\n");
printf("You can check the registration in two ways:\n");
printf("\n");
printf("  # The registration is created implicitly from the vox2ras matrix\n");
printf("  # (that is what --regheader does). There's no need to specify\n");
printf("  # and input registration\n");
printf("  tkregister2 --mov f.new.vox2ras.nii.gz --s bert --regheader --reg /tmp/reg\n");
printf("\n");
printf("  # Display the functional as an overlay in tkmedit (no registration\n");
printf("  # needed).\n");
printf("  tkmedit bert orig.mgz -overlay f.new.vox2ras.nii.gz\n");
printf("\n");
printf("1.D Map a binary mask in functional space to anatomical space. This is\n");
printf("basically the same cmd line as 1.A, but --interp nearest has been\n");
printf("added so that it does not try to interpolate the mask (ie, it will\n");
printf("still be binary after resampling):\n");
printf("\n");
printf("mri_vol2vol --reg register.dat --mov mask.nii.gz --fstarg \\\n");
printf("   --o mask-in-anat.mgh --interp nearest\n");
printf("\n");
printf("2. Map functional to/from talairach (MNI305) space. This uses a\n");
printf("two-stage registration: func-to-anat (register.dat) and\n");
printf("anat-to-talairach (talairach.xfm).\n");
printf("\n");
printf("Make sure that sure the func-to-anat reg is correct as was done in\n");
printf("Example 1. Next, make sure that the anat-to-tal is correct with:\n");
printf("\n");
printf("tkregister2 --s bert --fstal\n");
printf("\n");
printf("2.A Map functional to talairach (MNI305) space with 2mm isotropic\n");
printf("resolution. This is very similar to 1.A with the addition of --tal\n");
printf("and --talres 2.\n");
printf("\n");
printf("mri_vol2vol --mov f.nii.gz --reg register.dat \\\n");
printf("     --o f-in-tal.2mm.mgh --tal --talres 2\n");
printf("\n");
printf("f-in-tal.2mm.mgh will be 2mm isotropic with the same geometry as\n");
printf("$FREESURFER_HOME/average/mni305.cor.subfov2.mgz. This command will\n");
printf("also create f-in-tal.2mm.mgh.reg, which will register the volume with\n");
printf("any average MNI305 FreeSurfer subject (fsaverage is used by default).\n");
printf("The resampling can be checked with:\n");
printf("\n");
printf("  # This will show the functional with the fsaverage anatomical\n");
printf("  tkregister2 --mov f-in-tal.2mm.mgh --reg f-in-tal.2mm.mgh.reg\n");
printf("\n");
printf("2.B Map functional to talairach (MNI305) space with 1mm isotropic\n");
printf("resolution. Same as 2.A but use --talres 1.\n");
printf("\n");
printf("mri_vol2vol --mov f.nii.gz --reg register.dat \\\n");
printf("     --o f-in-tal.1mm.mgh --tal --talres 1\n");
printf("\n");
printf("f-in-tal.1mm.mgh will take up 8 times as much space as f-in-tal.2mm.mgh\n");
printf("\n");
printf("3. Apply an MNI transform to data by resampling the anatomical orig.mgz\n");
printf("into talairach space using bert/mri/transforms/talairach.xfm:\n");
printf("\n");
printf("First, check that the talairach.xfm is correct (this is basically the same\n");
printf("thing as 'tkregister2 --s bert --fstal' in Example 2:\n");
printf("\n");
printf(" cd bert/mri\n");
printf(" tkregister2 --targ orig.mgz \\\n");
printf("     --mov $FREESURFER_HOME/average/mni305.cor.mgz \\\n");
printf("     --xfm transforms/talairach.xfm --reg /tmp/reg\n");
printf("\n");
printf(" Now resample\n");
printf(" mri_vol2vol --mov orig.mgz \\\n");
printf("     --targ $FREESURFER_HOME/average/mni305.cor.mgz \\\n");
printf("     --xfm transforms/talairach.xfm  \\\n");
printf("     --o orig-in-mni305.mgz\n");
printf("\n");
printf(" Now test the resampling:\n");
printf(" tkregister2 --mov orig-in-mni305.mgz \\\n");
printf("    --targ $FREESURFER_HOME/average/mni305.cor.mgz \\\n");
printf("    --reg /tmp/reg --regheader\n");
printf("\n");
printf("\n");
printf("FORMATS\n");
printf("\n");
printf("Data file format can be specified implicitly (through the path name)\n");
printf("or explicitly. All formats accepted by mri_convert can be used.\n");
printf("\n");
printf("BUGS\n");
printf("\n");
printf("sinc interpolation is broken except for maybe COR to COR.\n");
printf("\n");
printf("\n");
printf("BUG REPORTING\n");
printf("\n");
printf("Report bugs to analysis-bugs@nmr.mgh.harvard.edu. Include the following\n");
printf("formatted as a list as follows: (1) command-line, (2) directory where\n");
printf("the program was run (for those in the MGH-NMR Center), (3) version,\n");
printf("(4) text output, (5) description of the problem.\n");
printf("\n");
printf("SEE ALSO\n");
printf("\n");
printf("mri_convert, tkregister2\n");
printf("\n");
printf("\n");
  exit(1) ;
}
/* --------------------------------------------- */
static void check_options(void) {
  SUBJECTS_DIR = getenv("SUBJECTS_DIR");
  if (SUBJECTS_DIR==NULL) {
    printf("ERROR: SUBJECTS_DIR undefined.\n");
    exit(1);
  }
  if (movvolfile == NULL) {
    printf("ERROR: No mov volume supplied.\n");
    exit(1);
  }
  if(outvolfile == NULL && DispFile == NULL) {
    printf("ERROR: No output volume supplied.\n");
    exit(1);
  }
  if(outvolfile){
    outdir = fio_dirname(outvolfile);
    err = mkdir(outdir,0777);
    if (err != 0 && errno != EEXIST) {
      printf("ERROR: creating directory %s\n",outdir);
      exit(1);
    }
  }

  if(!fstal && !DoCrop && !fstarg && targvolfile == NULL) {
    printf("ERROR: No targ volume supplied.\n");
    exit(1);
  }
  if(fstarg && targvolfile != NULL) {
    printf("ERROR: Do not specify a targ volume with --fstarg.\n");
    exit(1);
  }
  if(DoCrop && targvolfile != NULL) {
    printf("ERROR: Do not specify a targ volume with --crop.\n");
    exit(1);
  }
  if(fstal && targvolfile != NULL) {
    printf("ERROR: Do not specify a targ volume with --tal.\n");
    exit(1);
  }
  if(fstal && fstarg) {
    printf("ERROR: cannot specify a --tal and --fstarg.\n");
    exit(1);
  }
  if(xfmfile != NULL && regfile != NULL) {
    printf("ERROR: cannot specify both --xfm and --reg.\n");
    exit(1);
  }
  if (regheader && regfile != NULL) {
    printf("ERROR: cannot specify both --regheader and --reg.\n");
    exit(1);
  }
  if(fstarg && regfile == NULL && subject == NULL) {
    printf("ERROR: Need --reg with --fstarg.\n");
    exit(1);
  }
  if(fstarg) {
    sprintf(tmpstr,"%s/%s/mri/%s",SUBJECTS_DIR,subject,fstargfile);
    if (!fio_FileExistsReadable(tmpstr))
      sprintf(tmpstr,"%s/%s/mri/orig",SUBJECTS_DIR,subject);
    targvolfile = strcpyalloc(tmpstr);
    printf("Using %s as targ volume\n",targvolfile);
  }

  interpcode = MRIinterpCode(interpmethod);
  if (interpcode < 0) {
    printf("ERROR: interpolation method %s unrecognized\n",interpmethod);
    printf("       legal values are nearest, trilin, and sinc\n");
    exit(1);
  }

  return;
}
/* --------------------------------------------- */
static void dump_options(FILE *fp) {
  fprintf(fp,"movvol %s\n",movvolfile);
  if (targvolfile)
    fprintf(fp,"targvol %s\n",targvolfile);
  fprintf(fp,"outvol %s\n",outvolfile);
  if (regfile) fprintf(fp,"regfile %s\n",regfile);
  if (xfmfile) fprintf(fp,"xfmfile %s\n",xfmfile);
  fprintf(fp,"invert %d\n",invert);
  fprintf(fp,"tal    %d\n",fstal);
  fprintf(fp,"talres %d\n",fstalres);
  fprintf(fp,"regheader %d\n",regheader);
  fprintf(fp,"noresample %d\n",noresample);
  fprintf(fp,"interp  %s (%d)\n",interpmethod,interpcode);
  if (interpcode == SAMPLE_SINC) fprintf(fp,"sinc hw  %d\n",sinchw);
  fprintf(fp,"precision  %s (%d)\n",precision,precisioncode);
  fprintf(fp,"Gdiag_no  %d\n",Gdiag_no);

  if(DoMorph){
    fprintf(fp,"Morphing\n");
    fprintf(fp,"InvertMorph %d\n",InvertMorph);
  }

  fprintf(fp,"Synth      %d\n",synth);
  fprintf(fp,"SynthSeed  %d\n",SynthSeed);

  return;
}
/* --------------------------------------------- */
static void print_version(void) {
  printf("%s\n", vcid) ;
  exit(1) ;
}
/* --------------------------------------------- */
static void argnerr(char *option, int n) {
  if (n==1)
    fprintf(stderr,"ERROR: %s flag needs %d argument\n",option,n);
  else
    fprintf(stderr,"ERROR: %s flag needs %d arguments\n",option,n);
  exit(-1);
}
/*---------------------------------------------------------------*/
static int singledash(char *flag) {
  int len;
  len = strlen(flag);
  if (len < 2) return(0);
  if (flag[0] == '-' && flag[1] != '-') return(1);
  return(0);
}
/*---------------------------------------------------------------*/
static int isflag(char *flag) {
  int len;
  len = strlen(flag);
  if (len < 2) return(0);

  if (flag[0] == '-' && flag[1] == '-') return(1);
  return(0);
}
/*---------------------------------------------------------------*/
static int nth_is_arg(int nargc, char **argv, int nth) {
  /* Checks that nth arg exists and is not a flag */
  /* nth is 0-based */

  /* check that there are enough args for nth to exist */
  if (nargc <= nth) return(0);

  /* check whether the nth arg is a flag */
  if (isflag(argv[nth])) return(0);

  return(1);
}

/*------------------------------------------------------------
  istringnmatch() - compare the first n characters of two strings,
  return a 1 if they match (ignoring case), a zero otherwise. If
  n=0, then do a full comparison.
  ------------------------------------------------------------*/
static int istringnmatch(char *str1, char *str2, int n) {
  if (n > 0  && ! strncasecmp(str1,str2,n)) return(1);
  if (n <= 0 && ! strcasecmp(str1,str2)) return(1);
  return(0);
}
static MATRIX *LoadRtal(int talres) {
  char *FSH;
  char rtalfile[2000];
  float ipr, bpr, intensity;
  int float2int, err;
  MATRIX *Rtal;

  FSH = getenv("FREESURFER_HOME");
  if (FSH==NULL) {
    printf("ERROR: FREESURFER_HOME undefined.\n");
    exit(1);
  }
  sprintf(rtalfile,"%s/average/mni305.cor.subfov%d.reg",FSH,talres);
  err = regio_read_register(rtalfile, &subject, &ipr, &bpr,
                            &intensity, &Rtal, &float2int);
  if (err) exit(1);
  return(Rtal);
}
/*-----------------------------------------------------*/
MATRIX *LoadRfsl(char *fname) {
  MATRIX *FSLRegMat;
  FILE *fp;
  int i,j,n;

  fp = fopen(fname,"r");
  if (fp == NULL) {
    printf("ERROR: cannot open %s\n",fname);
    exit(1);
  }
  FSLRegMat = MatrixAlloc(4,4,MATRIX_REAL);
  for (i=0;i<4;i++) {
    for (j=0;j<4;j++) {
      n = fscanf(fp,"%f",&(FSLRegMat->rptr[i+1][j+1]));
      if (n != 1) {
        printf("ERROR: reading %s, row %d, col %d\n",fname,i,j);
        return(NULL);
      }
    }
  }
  return(FSLRegMat);
}


MRI *MRIapplyVSM(MRI *src, MRI *vsm)
{
  MRI *out;
  int c,r,s;
  float dr,val;

  out = MRIallocSequence(src->width, src->height, src->depth, 
			 MRI_FLOAT, src->nframes);
  MRIcopyHeader(src,out);
  
  for(c=0; c < src->width; c++){
    for(r=0; r < src->height; r++){
      for(s=0; s < src->depth; s++){
	dr = r + MRIgetVoxVal(vsm,c,r,s,0);
	MRIsampleSeqVolume(src, c, dr, s, &val, 0,0);
	MRIsetVoxVal(out,c,r,s,0,val);
      }
    }
  }

  return(out);
}

